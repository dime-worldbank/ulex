[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robert Marty. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Marty R (2024). ulex: Unique Location Extrator. R package version 0.1.0.","code":"@Manual{,   title = {ulex: Unique Location Extrator},   author = {Robert Marty},   year = {2024},   note = {R package version 0.1.0}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Unique Location Extrator","text":"Text often contains references locations events want extract location event. example, consider example tweet reports road traffic crash Nairobi, Kenya, interested determining location crash: crash occurred near garden city thika road way towards roysambu. tweet contains three location references: (1) garden city, (2) thika road (3) roysambu, ‘garden city’ name multiple locations 20 kilometers apart. , interested extracting location garden city location thika road represents crash site. Unique Location Extractor (ULEx) geoparses text extract unique location events. algorithm takes advantage contextual information contained within text (references roads administrate areas, neighborhoods) determines location references reference event interest ignored. package originally developed extract locations road traffic crashes reports crashes via Twitter, specifically context Nairobi, Kenya using Twitter feed @Ma3Route.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Unique Location Extrator","text":"can install development version ulex GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"worldbank/rsocialwatcher\")"},{"path":"/index.html","id":"main-functions","dir":"","previous_headings":"","what":"Main functions","title":"Unique Location Extrator","text":"package contains two main functions: augment_gazetteer: backbone locating events looking location references gazetteer, geographic dictionary. augment_gazetteer facilitates cleaning gazetteer may constructed sources OpenStreetMaps, Geonames Google Maps. locate_event: Takes text input returns location relevant event. Key inputs include text geoparse, gazetteer landmarks, spatial files roads areas (e.g., neighborhoods) list event words.","code":""},{"path":"/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Unique Location Extrator","text":"Setup Create location datasets Dataset Wards Dataset roads Dataset landmarks (landmark gazetteer)","code":""},{"path":"/index.html","id":"setup-","dir":"","previous_headings":"Quick Start","what":"Setup","title":"Unique Location Extrator","text":"","code":"#### Install package ## Install/Load Package Dependencies if (!require(\"pacman\")) install.packages(\"pacman\") pacman::p_load(magrittr, lubridate, dplyr, tidyr, readr, purrr, tidytext,                stringr, stringi, ngram, hunspell, stringdist, tm, raster,                parallel, jsonlite, sf, quanteda, geodist)  library(spacyr)  ## Load ULEx Functions source(\"~/Documents/Github/ulex/R/helper_functions.R\") source(\"~/Documents/Github/ulex/R/augment_gazetteer.R\") source(\"~/Documents/Github/ulex/R/locate_event.R\")  library(geodata) library(osmdata) library(ggplot2) library(stringr)"},{"path":[]},{"path":"/index.html","id":"dataset-of-wards-","dir":"","previous_headings":"Quick Start > Create location datasets","what":"Dataset of Wards","title":"Unique Location Extrator","text":"create dataset Wards Nairobi GADM.","code":"ken_sf <- gadm(country = \"KEN\", level = 3, path = tempdir()) %>% st_as_sf() nbo_sf <- ken_sf %>%   filter(NAME_1 %in% \"Nairobi\") %>%   rename(name = NAME_3) %>%   dplyr::select(name)  head(nbo_sf) #> Simple feature collection with 6 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 36.67803 ymin: -1.302667 xmax: 36.81967 ymax: -1.256238 #> Geodetic CRS:  WGS 84 #>         name                       geometry #> 1     Gatina POLYGON ((36.7601 -1.268443... #> 2 Kileleshwa POLYGON ((36.81139 -1.27213... #> 3   Kilimani POLYGON ((36.75393 -1.28606... #> 4     Kabiro POLYGON ((36.7373 -1.275437... #> 5 Kawangware POLYGON ((36.74915 -1.27165... #> 6   Mutu-Ini POLYGON ((36.67803 -1.29837..."},{"path":"/index.html","id":"dataset-of-roads-","dir":"","previous_headings":"Quick Start > Create location datasets","what":"Dataset of roads","title":"Unique Location Extrator","text":"create dataset roads OpenStreetMaps.","code":"roads_sf <- opq(st_bbox(nbo_sf), timeout = 999) %>%   add_osm_feature(key = \"highway\", value = c(\"motorway\",                                              \"trunk\",                                              \"primary\",                                              \"secondary\",                                              \"tertiary\",                                              \"unclassified\")) %>%   osmdata_sf() roads_sf <- roads_sf$osm_lines  roads_sf <- roads_sf %>%   filter(!is.na(name)) %>%   dplyr::select(name) %>%   mutate(name = name %>% tolower())  head(roads_sf) #> Simple feature collection with 6 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 36.80283 ymin: -1.348233 xmax: 36.91442 ymax: -1.286476 #> Geodetic CRS:  WGS 84 #>                              name                       geometry #> 4685092        airport south road LINESTRING (36.91442 -1.344... #> 4716860        state house avenue LINESTRING (36.80434 -1.286... #> 4716861          processional way LINESTRING (36.81367 -1.287... #> 4716862           kenyatta avenue LINESTRING (36.81026 -1.289... #> 4716887           kenyatta avenue LINESTRING (36.81188 -1.289... #> 4723375 city mortuary round about LINESTRING (36.80306 -1.298..."},{"path":"/index.html","id":"dataset-of-landmarks-landmark-gazetteer-","dir":"","previous_headings":"Quick Start > Create location datasets","what":"Dataset of landmarks (landmark gazetteer)","title":"Unique Location Extrator","text":"create gazetteer landmarks OpenStreetMaps. OpenStreetMaps, use amenities bus stops.","code":"# Amenities -------------------------------------------------------------------- amenities_sf <- opq(st_bbox(nbo_sf), timeout = 999) %>%   add_osm_feature(key = \"amenity\") %>%   osmdata_sf()  amenities_pnt_sf <- amenities_sf$osm_points amenities_ply_sf <- amenities_sf$osm_polygons %>%   st_centroid()  amenities_sf <- bind_rows(amenities_pnt_sf,                           amenities_ply_sf) %>%   dplyr::mutate(type = amenity)  # Bus Stops -------------------------------------------------------------------- busstops_sf <- opq(st_bbox(nbo_sf), timeout = 999) %>%   add_osm_feature(key = \"highway\",                   value = \"bus_stop\") %>%   osmdata_sf()  busstops_sf <- busstops_sf$osm_points  busstops_sf <- busstops_sf %>%   mutate(type = \"bus_stop\")  # Append ----------------------------------------------------------------------- landmarks_sf <- bind_rows(amenities_sf,                           busstops_sf) %>%   filter(!is.na(name)) %>%   dplyr::select(name, type) %>%   mutate(name = name %>% tolower())  head(landmarks_sf) #> Simple feature collection with 6 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 36.70606 ymin: -1.325597 xmax: 36.80624 ymax: -1.292358 #> Geodetic CRS:  WGS 84 #>                                        name             type #> 30031187 regina caeli karen catholic church place_of_worship #> 30088423                        china plate       restaurant #> 30088443                              rubis             fuel #> 30088444                      shell kabuagi             fuel #> 30088453               karen police station           police #> 30092033                              total             fuel #>                            geometry #> 30031187  POINT (36.7107 -1.325597) #> 30088423 POINT (36.80624 -1.292358) #> 30088443 POINT (36.71747 -1.317521) #> 30088444 POINT (36.71842 -1.316594) #> 30088453 POINT (36.70606 -1.321773) #> 30092033 POINT (36.78867 -1.299975)"},{"path":"/index.html","id":"map-locations","dir":"","previous_headings":"Quick Start > Create location datasets","what":"Map locations","title":"Unique Location Extrator","text":"","code":"ggplot() +   geom_sf(data = roads_sf,           aes(color = \"Roads\"),           linewidth = 0.6) +   geom_sf(data = landmarks_sf,           aes(color = \"Landmarks\"),           size = 0.1,           alpha = 0.5) +   geom_sf(data = nbo_sf,           fill = \"gray\",           aes(color = \"Wards\"),           linewidth = 0.5,           alpha = 0.2) +   labs(color = NULL,        title = \"Landmarks, Roads, and Wards\") +   scale_color_manual(values = c(\"blue\", \"chartreuse3\", \"black\")) +   theme_void() +   theme(plot.title = element_text(face = \"bold\"))"},{"path":"/index.html","id":"augment-gazetteer-","dir":"","previous_headings":"Quick Start","what":"Augment Gazetteer","title":"Unique Location Extrator","text":"","code":"landmarks_aug_sf <- augment_gazetteer(landmarks_sf)"},{"path":"/index.html","id":"locate-events-","dir":"","previous_headings":"Quick Start","what":"Locate Events","title":"Unique Location Extrator","text":"geolocate 5 tweets. crash garden city","code":"tweets <- c(\"crash at garden city\",             \"crash occurred near garden city on thika road on your way towards              roysambu\",             \"crash at intersection of juja road and outer ring rd\",             \"crash occured near roysambu on thika rd\",             \"crash near mathare centre along juja road\")  crashes_sf <- locate_event(text = tweets,                            landmark_gazetteer = landmarks_aug_sf,                            areas = nbo_sf,                            roads = roads_sf,                            event_words = c(\"accident\", \"crash\", \"collision\",                                             \"wreck\", \"overturn\")) ggplot() +   geom_sf() +   geom_sf(data = nbo_sf,           fill = \"gray\",           color =\"gray\") +   geom_sf(data = crashes_sf,           pch = 21,           color = \"black\",           fill = \"red\") +   theme_void()"},{"path":[]},{"path":"/index.html","id":"augment_gazetteer","dir":"","previous_headings":"Additional information for main functions","what":"augment_gazetteer","title":"Unique Location Extrator","text":"augment_gazetteer function adds additional landmarks account different ways saying landmark name. example, raw gazetteers may contain long, formal names, shorter versions name often used. addition, function facilitates removing landmarks names spurious may confuse algorithm; include landmark names common words may used different contexts, frequent generic landmarks hotel. Key components function include: Adding additional landmarks based n-grams skip-grams landmark names. example, original landmark garden city mall, following landmarks added: garden city, city mall, garden mall. Adding landmarks according set rules: example, landmark starts ends certain word, alternative version landmark added removes word. , words along categories landmarks removed, user may reference category; example, user likely say McDonalds McDonalds restaurant. Removes landmarks refer large geographic areas (e.g., roads). Roads areas dealt separately; function focuses cleaning gazetteer specific points/landmarks.","code":""},{"path":"/index.html","id":"locate_event","dir":"","previous_headings":"Additional information for main functions","what":"locate_event","title":"Unique Location Extrator","text":"locate_event function extracts landmarks text determines unique location events text. algorithm works two steps: (1) finding locations text (2) determining unique location. Finding location references text extract location references text, function implements following steps extract location references text. Determines whether text matches names gazetteer. exact ‘fuzzy’ matches (allowing certain Levenstein distance) used. Rely words prepositions find locations. algorithm starts word preposition extracts landmarks contain word. , algorithm takes next word text subsets landmarks. process repeated adding word removes landmarks. road area (eg, neighborhood) found previous step, landmarks near road neighborhood considered. Landmarks shortest number words kept (.e., process finds 5 landmarks 2 words 7 landmarks 3 words, 5 landmarks 2 words kept). road area mentioned landmark near road landmark, longer versions landmark near road area searched . example, user says crash near garden thika road, algorithm may extract multiple landmarks name garden, none near Thika road. search landmarks contain garden (e.g., garden city mall) near Thika road. two roads mentioned, algorithm extracts intersection roads. Determine unique location extracting landmarks, algorithm seeks identify single location using series steps. steps consider defined list event words (eg, road traffic crashes, include ‘crash’, ‘accident’, ‘overturn’, etc), whether user mentions junction word (e.g., ‘junction’ ‘intersection’) list prepositions. Certain prepositions given precedent others distinguish locations indicating location event versus locations away provide additional context; example, takes higher precedence towards. following main series steps used following order: Locations follow pattern [event word] [preposition] [location] extracted. Locations follow pattern [preposition] [location] extracted. multiple occurrences, location near higher order preposition used. tie, location closest event word used. junction word used, two roads mentioned, two roads intersect , intersection point used. location closest event word within text used. location name multiple locations, (1) restrict locations near mentioned road area, (2) check dominant cluster locations (3) prioritize certain landmark types others (e.g., user likely reference large, well known location type like stadium). landmark found, road area found, road area returned. road area mentioned, intersection road area returned.","code":""},{"path":"/reference/augment_gazetteer.html","id":null,"dir":"Reference","previous_headings":"","what":"Augments Landmark Gazetteer — augment_gazetteer","title":"Augments Landmark Gazetteer — augment_gazetteer","text":"Augments Landmark Gazetteer","code":""},{"path":"/reference/augment_gazetteer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augments Landmark Gazetteer — augment_gazetteer","text":"","code":"augment_gazetteer(   landmarks,   landmarks.name_var = \"name\",   landmarks.type_var = \"type\",   grams.min_words = 3,   grams.max_words = 6,   grams.skip_gram_first_last_word_match = TRUE,   grams.add_only_if_name_new = FALSE,   grams.add_only_if_specific = FALSE,   types_rm = c(\"route\", \"road\", \"toilet\", \"political\", \"locality\", \"neighborhood\",     \"area\", \"section of populated place\"),   types_rm.except_with_type = c(\"flyover\", \"round about\", \"roundabout\"),   types_rm.except_with_name = c(\"flyover\", \"round about\", \"roundabout\"),   parallel.sep_slash = TRUE,   parallel.rm_begin = c(tm::stopwords(\"en\"), c(\"near\", \"at\", \"the\", \"towards\", \"near\")),   parallel.rm_end = c(\"bar\", \"shops\", \"restaurant\", \"sports bar\", \"hotel\", \"bus station\"),   parallel.word_diff = \"default\",   parallel.word_diff_iftype = list(list(words = c(\"stage\", \"bus stop\", \"bus station\"),     type = \"transit_station\")),   parallel.rm_begin_iftype = NULL,   parallel.rm_end_iftype = list(list(words = c(\"stage\", \"bus stop\", \"bus station\"), type     = \"transit_station\")),   parallel.word_begin_addtype = NULL,   parallel.word_end_addtype = list(list(words = c(\"stage\", \"bus stop\", \"bus station\"),     type = \"stage\")),   parallel.add_only_if_name_new = FALSE,   parallel.add_only_if_specific = FALSE,   rm.contains = c(\"road\", \"rd\"),   rm.name_begin = c(tm::stopwords(\"en\"), c(\"near\", \"at\", \"the\", \"towards\", \"near\")),   rm.name_end = c(\"highway\", \"road\", \"rd\", \"way\", \"ave\", \"avenue\", \"street\", \"st\"),   pos_rm.all = c(\"ADJ\", \"ADP\", \"ADV\", \"AUX\", \"CCONJ\", \"INTJ\", \"NUM\", \"PRON\", \"SCONJ\",     \"VERB\", \"X\"),   pos_rm.except_type = list(pos = c(\"NOUN\", \"PROPN\"), type = c(\"bus\", \"restaurant\",     \"bank\")),   close_thresh_km = 1,   quiet = TRUE )"},{"path":"/reference/augment_gazetteer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augments Landmark Gazetteer — augment_gazetteer","text":"landmarks sf spatial points data.frame landmarks. landmarks.name_var Name variable indicating name landmark. (Default: \"name\"). landmarks.type_var Name variable indicating type landmark. (Default: \"type\"). grams.min_words Minimum number words name make n/skip-grams name. (Default: 3). grams.max_words Maximum number words name make n/skip-grams name. Setting cap helps reduce spurious landmarks may come really long names. (Default: 6). grams.skip_gram_first_last_word_match skip-grams, first last word original word? (Default: TRUE). grams.add_only_if_name_new creating new landmarks based n- skip-grams, add additional landmark name landmark new; .e., name already exist gazetteer. (Default: FALSE). grams.add_only_if_specific creating new landmarks based n- skip-grams, add additional landmark name landmark represents specific location. specific location location landmark entries name close together (within close_thresh_km kilometers). (Default: FALSE). types_rm landmark one types, remove - unless types_rm.except_with_type types_rm.except_with_name prevents removing. (Default: c(\"route\", \"road\", \"toilet\", \"political\", \"locality\", \"neighborhood\", \"area\", \"section populated place\")). types_rm.except_with_type Landmark types always keep. parameter becomes relevant cases landmark one type. landmark \"types_rm\" \"types_always_keep\" landmark, landmark kept. (Default: c(\"flyover\", \"round \", \"roundabout\")). types_rm.except_with_name Landmark names always keep. parameter becomes relevant cases landmark one \"types_rm\" , keep landmark \"names_always_keep\" somewhere name. example, landmark road flyover name, may want keep landmark flyovers small spatial areas. (Default: c(\"flyover\", \"round \", \"roundabout\")). parallel.sep_slash landmark contains slash, create new landmarks slash. (Default: TRUE). parallel.rm_begin landmark name begins one words, add landmark excludes word. (Default: c(tm::stopwords(\"en\"), c(\"near\",\"\",\"\", \"towards\", \"near\"))). parallel.rm_end landmark name ends one words, add landmark excludes word. (Default: c(\"bar\", \"shops\", \"restaurant\",\"sports bar\",\"hotel\", \"bus station\")). parallel.word_diff landmark includes one words, add landmark swaps word word (e.g., \"center\" \"centre\"). default, uses set collection words. Users can also manually specify different word versions. Input data.frame following variables: version_1 (one spelling word) version_2 (second spelling word). parallel.word_diff_iftype landmark includes one words, add landmark swaps word word (e.g., \"bus stop\" \"bus station\"). Enter named list words, words = c() type = c(). (Default: list(list(words = c(\"stage\", \"bus stop\",  \"bus station\"), type = \"transit_station\"))). parallel.rm_begin_iftype landmark name begins one words, add landmark excludes word landmark certain type. (Default: NULL). parallel.rm_end_iftype landmark name ends one words, add landmark excludes word landmark certain type. (Default: list(list(words = c(\"stage\", \"bus stop\",  \"bus station\"), type = \"transit_station\"))). parallel.word_begin_addtype landmark begins one words, add type. example, landmark \"restaurant\", indicates landmark restaurant. Adding \"restaurant\" landmark ensures type reflected. (Default: NULL). parallel.word_end_addtype landmark ends one words, add type. example, landmark \"X stage\", indicates landmark bus stage. Adding \"stage\" landmark ensures type reflected. (Default: list(list(words = c(\"stage\", \"bus stop\", \"bus station\"), type = \"stage\"))). parallel.add_only_if_name_new creating parallel landmarks using parameters, add additional landmark name landmark new; .e., name already exist gazetteer. (Default: FALSE). parallel.add_only_if_specific creating parallel landmarks using parameters, add additional landmark name landmark represents specific location. specific location location landmark entries name close together (within close_thresh_km kilometers). (Default: FALSE). rm.contains Remove landmark contains one words. Implemented N/skip-grams parallel landmarks added. (Default: c(\"road\", \"rd\")). rm.name_begin Remove landmark begins one words. Implemented N/skip-grams parallel landmarks added. (Default: c(tm::stopwords(\"en\"), c(\"near\",\"\",\"\", \"towards\", \"near\"))). rm.name_end Remove landmark ends one words. Implemented N/skip-grams parallel landmarks added. (Default: c(\"highway\", \"road\", \"rd\", \"way\", \"ave\", \"avenue\", \"street\", \"st\")). pos_rm.Part--speech categories remove. Part--speech determined Spacy. (Default: c(\"ADJ\", \"ADP\", \"ADV\", \"AUX\", \"CCONJ\", \"INTJ\", \"NUM\", \"PRON\", \"SCONJ\", \"VERB\", \"X\")). pos_rm.except_type specify part--speech categories remove pos_rm., override pos_rm.keep word. Names list : (1) pos (word also another type part--speech); (2) type (word also certain type place); (3) name (word includes certain text). Example: list(pos = c(\"NOUN\", \"PROPN\"), type = c(\"bus\", \"restaurant\", \"bank\"), name = c(\"parliament\")). (Default: list(pos = c(\"NOUN\", \"PROPN\"), type = c(\"bus\", \"restaurant\", \"bank\"))). close_thresh_km consider locations close together. Used determining landmark name multiple locations specific (close together) general (far apart). (Default: 1). quiet Print progress function. (Default: TRUE).","code":""},{"path":"/reference/augment_gazetteer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augments Landmark Gazetteer — augment_gazetteer","text":"sf spatial point data.frame landmarks.","code":""},{"path":"/reference/locate_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate Event — locate_event","title":"Locate Event — locate_event","text":"Locate Event","code":""},{"path":"/reference/locate_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate Event — locate_event","text":"","code":"locate_event(   text,   landmark_gazetteer,   landmark_gazetteer.name_var = \"name\",   landmark_gazetteer.type_var = \"type\",   roads,   roads.name_var = \"name\",   areas,   areas.name_var = \"name\",   event_words,   prepositions_list = list(c(\"at\", \"next to\", \"around\", \"just after\", \"opposite\", \"opp\",     \"apa\", \"hapa\", \"happened at\", \"just before\", \"at the\", \"outside\", \"right before\"),     c(\"near\", \"after\", \"toward\", \"along\", \"towards\", \"approach\"), c(\"past\", \"from\",     \"on\")),   junction_words = c(\"intersection\", \"junction\"),   false_positive_phrases = \"\",   type_list = NULL,   clost_dist_thresh = 500,   fuzzy_match = TRUE,   fuzzy_match.min_word_length = c(5, 11),   fuzzy_match.dist = c(1, 2),   fuzzy_match.ngram_max = 3,   fuzzy_match.first_letters_same = TRUE,   fuzzy_match.last_letters_same = TRUE,   quiet = T,   mc_cores = 1 )"},{"path":"/reference/locate_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate Event — locate_event","text":"text Vector texts geolocated. landmark_gazetteer sf spatial data.frame representing landmarks. landmark_gazetteer.name_var Name variable indicating name landmark. landmark_gazetteer.type_var Name variable indicating type landmark. roads sf spatial data.frame representing roads. roads.name_var Name variable indicating name road. areas sf spatial data.frame representing areas, administrative areas neighborhoods. areas.name_var Name variable indicating name area. event_words Vector event words, representing events geocoded. prepositions_list List vectors prepositions. Order list determines order preposition precedence. (Default: list(c(\"\", \"next \",\"around\", \"just \", \"opposite\",\"opp\", \"apa\", \"hapa\",\"happened \", \"just \",\"\",\"outside\", \"right \"), c(\"near\", \"\", \"toward\", \"along\", \"towards\", \"approach\"), c(\"past\",\"\",\"\"))). junction_words Vector junction words check determining intersection roads. (Default: c(\"intersection\", \"junction\")). false_positive_phrases Common words found text include spurious location references (eg, githurai bus name bus, githurai also place). may common phrases checked ignored text. (Default: \"\"). type_list List vectors types. Order list determines order type precedence. (Default: NULL). clost_dist_thresh Distance (meters) considered \"close\"; example, considering whether landmark close road. (Default: 500). fuzzy_match Whether implement fuzzy matching landmarks using levenstein distance. (Default: TRUE). fuzzy_match.min_word_length Minimum word length use fuzzy matching; vector length must fuzzy_match.dist. (Default: c(5,11)). fuzzy_match.dist Allowable levenstein distances fuzzy matching; vector length must fuzzy_match.min_word_length. (Default: c(1,2)). fuzzy_match.ngram_max number n-grams extracted text calculate levensteing distance landmarks. example, text composed 5 words: w1 w2 w3 w4 fuzzy_match.ngram_max = 3, function extracts w1 w2 w3 compares levenstein distance landmarks. checks w2 w3 w4, etc. (Default: 3). fuzzy_match.first_letters_same implementing fuzzy match, first letter original found word ? (Default: TRUE). fuzzy_match.last_letters_same implementing fuzzy match, last letter original found word ? (Default: TRUE). quiet FALSE, prints text geocoded. (Default: TRUE). mc_cores > 1, uses geolocates events parallel across multiple cores relying parallel package. (Default: 1).","code":""},{"path":"/reference/locate_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate Event — locate_event","text":"sf spatial dataframe geolocated events.","code":""}]
